<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星际公民新手教程</title>
    <style>
        /* 重置默认样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* 设置 html 和 body 元素占满整个视口 */
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* 隐藏滚动条 */
            font-family: Arial, sans-serif;
        }

        body {
            background: linear-gradient(to bottom, #000428, #001525); /* 深空渐变背景 */
            position: relative; /* 为伪元素定位提供参考 */
        }

         /* 星空容器样式 */
        #stars-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 星星不干扰鼠标事件 */
            z-index: 0; /* 确保层级最低 */
        }

        /* 星星样式 */
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle linear infinite;
            pointer-events: none; /* 确保星星不干扰事件 */
        }

        /* 星星闪烁动画定义 */
        @keyframes twinkle {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }

        /* 主内容容器 - 用于缩放和平移 */
        #zoom-pan-container {
            position: fixed; /* 使用 fixed 确保覆盖全屏 */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            transform-origin: 0 0; /* 设置变换原点为左上角 */
            z-index: 10; /* 确保层级高于星空 */
        }

        /* 内容包装器，包含所有可缩放平移的内容 */
        .content-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* 任务框基础样式 */
        .task-box {
            position: absolute;
            width: 120px;
            height: 50px;
            /* 白色背景改为带淡绿色透明度 */
            background-color: rgba(240, 255, 240, 0.8);
            color: black; /* 黑色字体 */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            text-align: center;
            padding: 5px 5px 5px 10px; /* 左侧留出空间给蓝色区域 */
            box-sizing: border-box;
            z-index: 20; /* 任务框层级较高 */
            user-select: none; /* 防止文本被选中 */
            cursor: pointer; /* 指针手型 */
            overflow: hidden; /* 隐藏溢出的伪元素 */
            transition: none; /* 移除过渡 */
        }

        /* 任务框待办状态指示器 (蓝色) */
        .task-box::before {
             content: '';
             position: absolute;
             top: 0;
             left: 0;
             height: 100%;
             width: 5px; /* 固定5px宽度 */
             background-color: #2196F3; /* 蓝色 */
             z-index: -1; /* 放在文字下方 */
        }

        /* 任务框完成状态指示器 (绿色) */
        .task-box::after {
             content: '';
             position: absolute;
             top: 0;
             left: 0;
             height: 100%;
             width: 0px; /* 初始宽度为0 */
             background-color: #4CAF50; /* 绿色 */
             z-index: -1; /* 放在文字下方和蓝色之上 */
             transition: none; /* 移除过渡 */
        }

        /* 已完成状态 - 绿色部分显示 */
        .task-box.completed::after {
             width: 5px; /* 完成时宽度为5px，覆盖蓝色 */
        }


        /* SVG 连接线容器样式 */
        .connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 禁用鼠标事件，使 SVG 不阻挡对下方元素的操作 */
            z-index: 15; /* 连接线层级在任务框之下 */
        }

        /* SVG 路径基础样式 */
        .connection-line {
            stroke: #999; /* 默认灰色 */
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
            /* 添加虚线和动画 */
            stroke-dasharray: 5, 5; /* 虚线模式 */
            animation: dash 1s linear infinite; /* 流动动画 */
        }

        /* 绿色连接线样式 */
        .connection-line.completed {
            stroke: #4CAF50; /* 绿色 */
        }

        /* SVG 虚线流动动画 */
        @keyframes dash {
            to {
                stroke-dashoffset: -10; /* 负值使虚线向右流动 */
            }
        }

        /* 提示信息样式 */
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            z-index: 30; /* 提示信息层级最高 */
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none; /* 提示信息不干扰事件 */
        }

        /* 弹窗背景虚化层 */
        #modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    
    /* 使用 backdrop-filter 实现高斯模糊 */
    backdrop-filter: blur(5px); /* 根据需要调整模糊半径 */
    
    /* 背景颜色为半透明黑色，可以根据需要调整透明度 */
    background-color: rgba(0, 0, 0, 0.3); 
    
    display: flex;
    justify-content: center;
    align-items: center;
    
    z-index: 9999;
    
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
}

         /* 弹窗背景虚化层 - 显示状态 */
        #modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        /* 弹窗主体 */
.modal-content {
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    width: 80%;
    max-width: 500px;
    position: relative;
    transform: scale(0.9);
    transition: transform 0.3s ease;
    /* --- 新增/修改字体样式 --- */
    font-family: "SimSun", "宋体", serif;
    font-size: 20px; /* 设置基础字体大小 */
    color: #333; /* 设置基础文字颜色 */
    /* --- 新增/修改字体样式结束 --- */
}

         /* 弹窗主体 - 显示状态 */
        #modal-overlay.show .modal-content {
             transform: scale(1);
        }

        /* 弹窗内的互动元素示例 */
        #modal-input {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        #modal-output {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
            min-height: 20px;
        }

        /* 注册按钮样式 - 加长版本 */
        .register-btn {
            display: block;
            background-color: #4CAF50;
            color: white;
            padding: 12px 30px;
            margin-top: 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            font-weight: bold;
            width: 100%;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .register-btn:hover {
            background-color: #45a049;
        }

        /* 新增的警告文本样式 */
        .warning-text {
    margin-top: 20px;
    font-size: 20px;
    color: #000000;
    font-family: "SimSun", "宋体", serif; /* 使用宋体 */
    font-weight: normal;                  /* 不加粗 */
    text-align: left;                     /* 左对齐 ← 修改这里 */
}
        .info-text {
            margin-top: 10px;
            font-size: 14px;
            color: #333;
            text-align: left;
        }

        /* --- 新增音乐控制图标样式 --- */
        #music-control {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 24px;
            color: #ffffff;
            cursor: pointer;
            z-index: 1000; /* 确保在最上层 */
            user-select: none; /* 防止选中 */
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        #music-control:hover {
            opacity: 1;
        }

        /* 旋转动画 */
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .rotating {
            animation: rotate 2s linear infinite;
        }
        /* --- 新增音乐控制图标样式结束 --- */

        /* --- 轮播图样式 --- */
.carousel-container {
    position: relative;
    width: 100%;
    height: 200px;
    margin-bottom: 15px;
    overflow: hidden;
    border-radius: 4px;
    cursor: pointer;
}

.carousel-slide {
    position: absolute;
    width: 100%;
    height: 100%;
    opacity: 0;
    transition: opacity 0.5s ease;
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    cursor: pointer;
}

.carousel-slide.active {
    opacity: 1;
}

.carousel-controls {
    position: absolute;
    bottom: 10px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    gap: 5px;
}

.carousel-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.5);
    cursor: pointer;
}

.carousel-dot.active {
    background-color: #fff;
}

.carousel-nav {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
    border-radius: 3px;
    z-index: 10;
}

.carousel-prev {
    left: 10px;
}

.carousel-next {
    right: 10px;
}

/* --- 全屏查看器样式 --- */
#image-viewer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease;
}

#image-viewer.show {
    opacity: 1;
    visibility: visible;
}

.viewer-content {
    position: relative;
    width: 75vw;
    height: 75vh;
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
}

.viewer-nav {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: none;
    padding: 15px;
    cursor: pointer;
    font-size: 24px;
    border-radius: 50%;
    z-index: 10;
}

.viewer-prev {
    left: 20px;
}

.viewer-next {
    right: 20px;
}

.viewer-close {
    position: absolute;
    top: 20px;
    right: 20px;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    border: none;
    padding: 10px 15px;
    cursor: pointer;
    font-size: 20px;
    border-radius: 50%;
    z-index: 10;
}

.viewer-dots {
    position: absolute;
    bottom: 20px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    gap: 10px;
}

.viewer-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.5);
    cursor: pointer;
}

.viewer-dot.active {
    background-color: #fff;
}
    </style>
</head>
<body>
    <!-- 星空背景容器 -->
    <div id="stars-container"></div>

    <!-- 缩放平移容器 -->
    <div id="zoom-pan-container">
        <!-- 内容包装器 -->
        <div class="content-wrapper">
<!---------------------------------------------------------------------------------------------------- 任务框 -----------------------------------------------------------------------------------------------------------------------------------------> 
            <div id="task1" class="task-box" data-task-id="task1" style="top: 20%; left: 50%; transform: translateX(-50%);">注册账号</div>
            <div id="task2" class="task-box" data-task-id="task2" style="top: 40%; left: 50%; transform: translateX(-50%);">购买资格包</div>
            <div id="task2.1" class="task-box" data-task-id="task2.1" style="top: 60%; left: 50%; transform: translateX(-50%);">准备启动器</div>
            <div id="task2.2" class="task-box" data-task-id="task2.2" style="top: 60%; left: 30%; transform: translateX(-50%);">汉化</div>
            <div id="task3" class="task-box" data-task-id="task3" style="top: 80%; left: 20%; transform: translateX(-50%);">社区</div>
            <div id="task4" class="task-box" data-task-id="task4" style="top: 80%; left: 40%; transform: translateX(-50%);">官网</div>
            <div id="task5" class="task-box" data-task-id="task5" style="top: 80%; left: 60%; transform: translateX(-50%);">星际公民</div>
            <div id="task6" class="task-box" data-task-id="task6" style="top: 80%; left: 80%; transform: translateX(-50%);">42中队</div>
<!---------------------------------------------------------------------------------------------------- 任务框 ----------------------------------------------------------------------------------------------------------------------------------------->
            <!-- SVG 连接线 -->
            <svg class="connections" xmlns="http://www.w3.org/2000/svg">
                <!-- 定义 SVG 中可重用的元素 -->
                <defs>
                    <!-- 定义箭头标记 -->
                    <marker id="arrowhead" markerWidth="10" markerHeight="7"
                            refX="10" refY="3.5" orient="auto" markerUnits="strokeWidth">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#999" />
                    </marker>
                    <!-- 定义绿色箭头标记 -->
                    <marker id="arrowhead-green" markerWidth="10" markerHeight="7"
                            refX="10" refY="3.5" orient="auto" markerUnits="strokeWidth">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#4CAF50" />
                    </marker>
                </defs>

 <!---------------------------------------------------------------------------------------------------- 父级到子级的连接线 (使用贝塞尔曲线) ----------------------------------------------------------------------------------------------------------------------------------------->
                <path id="line1-2" class="connection-line" data-parent="task1" data-child="task2"/>
                <path id="line2-2.1" class="connection-line" data-parent="task2" data-child="task2.1"/>
                <path id="line2-2.2" class="connection-line" data-parent="task2" data-child="task2.2"/>
                <path id="line2.1-3" class="connection-line" data-parent="task2.1" data-child="task3"/>
                <path id="line2.1-4" class="connection-line" data-parent="task2.1" data-child="task4"/>
                <path id="line2.1-5" class="connection-line" data-parent="task2.1" data-child="task5"/>
                <path id="line2.1-6" class="connection-line" data-parent="task2.1" data-child="task6"/>
            </svg>
        </div>
    </div>
    <!------------------------------------------------------------------------------------------------ - 父级到子级的连接线 (使用贝塞尔曲线) ----------------------------------------------------------------------------------------------------------------------------------------->

    <!-- 弹窗背景虚化层 -->
    <div id="modal-overlay">
        <!-- 弹窗主体 -->
        <div class="modal-content">
            <h3 id="modal-title">任务详情</h3>
            <div id="modal-content-area">
                <!-- 内容将根据任务类型动态填充 -->
            </div>
            <div id="modal-actions">
                <!-- 操作按钮区域 -->
            </div>
        </div>
    </div>

    <!-- 操作提示 -->
    <div id="instructions">
        鼠标滚轮缩放 | 鼠标拖拽移动 | 点击任务框查看详情
    </div>

    <!-- --- 新增音乐控制图标 --- -->
    <div id="music-control" title="点击静音/播放">&#127925;</div> <!-- 音符符号 -->
    <!-- --- 新增音乐控制图标结束 --- -->

    <!-- --- 新增隐藏的音频元素 --- -->
    <audio id="background-music" loop>
        <source src="c418.mp3" type="audio/mpeg">
        您的浏览器不支持音频元素。
    </audio>
    <!-- --- 新增隐藏的音频元素结束 --- -->

    <!-- 全屏图片查看器 -->
<div id="image-viewer">
    <button class="viewer-close">×</button>
    <button class="viewer-nav viewer-prev">&#10094;</button>
    <div class="viewer-content" id="viewer-image"></div>
    <button class="viewer-nav viewer-next">&#10095;</button>
    <div class="viewer-dots" id="viewer-dots"></div>
</div>

    <script>
        // 创建星空背景
        function createStars() {
            const container = document.getElementById('stars-container');
            if (!container) {
                 console.error("Stars container not found!");
                 return;
            }
            // 清空容器，以防重复创建
            container.innerHTML = '';
            const starCount = 200;

            for (let i = 0; i <starCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');

                // 随机位置 (使用 vw/vh 确保全屏分布)
                const x = Math.random() * 100;
                const y = Math.random() * 100;

                // 随机大小 (0.5px 到 2px)
                const size = Math.random() * 1.5 + 0.5;

                // 随机动画时长 (2s 到 5s)
                const duration = Math.random() * 3 + 2;

                // 随机动画延迟
                const delay = Math.random() * 5;

                star.style.left = `${x}vw`;
                star.style.top = `${y}vh`;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.animationDuration = `${duration}s`;
                star.style.animationDelay = `${delay}s`;
                // 确保星星层级最低
                star.style.zIndex = '0';

                container.appendChild(star);
            }
             console.log(`Created ${starCount} stars.`);
        }

        // 简单的函数来计算和绘制连接线 (考虑缩放)
        function drawCurvedLine(parentId, childId, lineId) {
            const parent = document.getElementById(parentId);
            const child = document.getElementById(childId);
            const line = document.getElementById(lineId);

            if (!parent || !child || !line) {
                console.error("Element not found for line drawing:", parentId, childId, lineId);
                return;
            }

            // 获取缩放容器的当前变换矩阵
            const container = document.getElementById('zoom-pan-container');
            // 使用 getComputedStyle 获取变换字符串，然后用 DOMMatrix 解析
            const computedStyle = window.getComputedStyle(container);
            const transformValue = computedStyle.transform === 'none' ? 'matrix(1, 0, 0, 1, 0, 0)' : computedStyle.transform;
            const matrix = new DOMMatrix(transformValue);

            // 获取元素相对于视口的位置和尺寸
            const parentRect = parent.getBoundingClientRect();
            const childRect = child.getBoundingClientRect();

            // 计算相对于缩放/平移后容器坐标系的坐标
            // 我们需要将视口坐标逆变换回容器坐标系
            const parentPointTopLeft = new DOMPoint(parentRect.left, parentRect.top).matrixTransform(matrix.inverse());
            const parentPointBottomRight = new DOMPoint(parentRect.right, parentRect.bottom).matrixTransform(matrix.inverse());

            const childPointTopLeft = new DOMPoint(childRect.left, childRect.top).matrixTransform(matrix.inverse());
            const childPointBottomRight = new DOMPoint(childRect.right, childRect.bottom).matrixTransform(matrix.inverse());

            // 在容器坐标系中计算连接点
            const pX = parentPointTopLeft.x + (parentPointBottomRight.x - parentPointTopLeft.x) / 2; // 父元素中心 X
            const pY = parentPointBottomRight.y; // 父元素底部 Y

            const cX = childPointTopLeft.x + (childPointBottomRight.x - childPointTopLeft.x) / 2; // 子元素中心 X
            const cY = childPointTopLeft.y; // 子元素顶部 Y

            // 创建贝塞尔曲线路径数据
            const cpY = (pY + cY) / 2;
            const pathData = `M ${pX} ${pY} C ${pX} ${cpY}, ${cX} ${cpY}, ${cX} ${cY}`;

            line.setAttribute('d', pathData);
        }

        // ———————————————————————————————————————————————————————————————————————————————————————————————————————————绘制所有连接线—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
        function drawAllLines() {
            drawCurvedLine('task1', 'task2', 'line1-2');
            drawCurvedLine('task2', 'task2.1', 'line2-2.1');
            drawCurvedLine('task2', 'task2.2', 'line2-2.2');
            drawCurvedLine('task2.1', 'task3', 'line2.1-3');
            drawCurvedLine('task2.1', 'task4', 'line2.1-4');
            drawCurvedLine('task2.1', 'task5', 'line2.1-5');
            drawCurvedLine('task2.1', 'task6', 'line2.1-6');
            // 更新连接线颜色状态
            updateConnectionColors();
        }
        // ———————————————————————————————————————————————————————————————————————————————————————————————————————————绘制所有连接线—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
       
        // --- 新增：检查任务及其所有祖先是否都完成 ---
        function isTaskAndAncestorsCompleted(taskId) {
            const taskElement = document.getElementById(taskId);
            if (!taskElement) {
                console.warn(`Task with ID ${taskId} not found.`);
                return false;
            }

            // 1. 检查自身是否完成
            if (!taskElement.classList.contains('completed')) {
                return false;
            }

            // 2. 递归检查父级
            // 找到所有以当前 taskId 为 child 的连接线
            const parentLines = document.querySelectorAll(`.connection-line[data-child="${taskId}"]`);
            for (const line of parentLines) {
                const parentId = line.dataset.parent;
                // 如果父级未完成，则整个链路未完成
                if (!isTaskAndAncestorsCompleted(parentId)) {
                    return false;
                }
            }

            // 如果自身完成，且所有父级都完成（或没有父级），则返回 true
            return true;
        }

        // 更新连接线颜色 (严格依赖版本)
        function updateConnectionColors() {
            document.querySelectorAll('.connection-line').forEach(line => {
                const childId = line.dataset.child; // 只需要检查子级及其祖先的状态

                // 核心逻辑：只有当子任务及其所有祖先都完成时，连接线才变绿
                if (isTaskAndAncestorsCompleted(childId)) {
                    line.classList.add('completed');
                    line.setAttribute('marker-end', 'url(#arrowhead-green)');
                } else {
                    line.classList.remove('completed');
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                }
            });
        }

        // --- 新增音乐控制相关逻辑 ---
        const audioElement = document.getElementById('background-music');
        const musicControl = document.getElementById('music-control');
        let isMusicPlaying = false; // 标记音乐是否正在播放
        // --- 新增变量：标记用户是否主动暂停过音乐 ---
        let hasUserMuted = false; // 新增：标记用户是否手动暂停过

        // 播放音乐并启动旋转动画
        function playMusic() {
            audioElement.play().then(() => {
                isMusicPlaying = true;
                musicControl.classList.add('rotating');
                console.log("音乐开始播放");
            }).catch(error => {
                console.error("播放音乐失败:", error);
                // 如果播放失败（例如用户未交互），静音状态保持不变
                isMusicPlaying = false;
                musicControl.classList.remove('rotating');
            });
        }

        // 暂停音乐并停止旋转动画
        function pauseMusic() {
            audioElement.pause();
            isMusicPlaying = false;
            musicControl.classList.remove('rotating');
            console.log("音乐暂停");
        }

        // 切换音乐播放/暂停状态
        function toggleMusic() {
            if (isMusicPlaying) {
                pauseMusic();
                // --- 新增：用户手动暂停时，设置标志位 ---
                hasUserMuted = true; // 用户点击暂停，设置标志
            } else {
                playMusic();
                // 可选：如果用户点击播放，是否重置标志？这里不重置，保持暂停状态有效
                // hasUserMuted = false;
            }
        }

        // 点击音符图标切换播放/暂停
        musicControl.addEventListener('click', (e) => {
            e.stopPropagation(); // 阻止事件冒泡
            toggleMusic();
        });

        // --- 新增音乐控制相关逻辑结束 ---

        // 弹窗相关逻辑
        const modalOverlay = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalContentArea = document.getElementById('modal-content-area');
        const modalActions = document.getElementById('modal-actions');
        let currentTaskBox = null; // 用来记录当前打开弹窗的任务框
        let cycleCount = {}; // 用来记录每个任务框的周期数 { taskId: count }

        // 点击任务框打开弹窗
        document.querySelectorAll('.task-box').forEach(task => {
            task.addEventListener('click', (e) => {
                e.stopPropagation(); // 阻止事件冒泡到document
                currentTaskBox = task; // 记录当前任务框
                const taskText = task.textContent;
                const taskId = task.id;

                // --- 修改：点击任务框后播放音乐的逻辑 ---
                // 只在第一次点击任意任务框时播放音乐，并且用户没有手动暂停过
                if (!isMusicPlaying && audioElement.readyState >= 2 && !hasUserMuted) { // 新增条件 !hasUserMuted
                     playMusic();
                }
                // --- 修改结束 ---

                // 清空弹窗内容
                modalContentArea.innerHTML = '';
                modalActions.innerHTML = '';

                // 设置标题
                modalTitle.textContent = `任务目标: ${taskText}`;





























                // 根据任务ID设置不同的内容
                if (taskId === 'task1') {
                    if (taskId === 'task1') {
    // 父级任务显示注册按钮和轮播图
    modalContentArea.innerHTML = `
        <div class="carousel-container" id="register-carousel">
            <div class="carousel-slide active" style="background-image: url('注册账号1.png');"></div>
            <div class="carousel-slide" style="background-image: url('注册账号2.png');"></div>
            <button class="carousel-nav carousel-prev">&#10094;</button>
            <button class="carousel-nav carousel-next">&#10095;</button>
            <div class="carousel-controls">
                <span class="carousel-dot active" data-index="0"></span>
                <span class="carousel-dot" data-index="1"></span>
            </div>
        </div>`;
    
}
    
    const registerBtn = document.createElement('a');
    registerBtn.href = 'https://robertsspaceindustries.com/en/enlist?referral=STAR-9KWF-Y7CS';
    registerBtn.target = '_blank';
    registerBtn.className = 'register-btn';
    registerBtn.textContent = '立即注册';
    registerBtn.addEventListener('click', (e) => {
        e.stopPropagation();
    });
    modalActions.appendChild(registerBtn);

    const warningText1 = document.createElement('div');
    warningText1.className = 'warning-text';
    warningText1.textContent = '慎重选择163邮箱注册，易被撞库洗号';
    const warningText2 = document.createElement('div');
    warningText2.className = 'warning-text';
    warningText2.textContent = '初始邮箱权重大，勿用非本人邮箱注册';
    modalActions.appendChild(warningText1);
    modalActions.appendChild(warningText2);
    
    // 初始化轮播图（无自动播放）
    initCarousel();
      
                } else if (taskId === 'task2') {
                    // 子级任务显示与父级相同的布局，但链接不同
                    modalContentArea.innerHTML = '<p>购买游戏资格包：</p>';
                    const registerBtn = document.createElement('a');
                    registerBtn.href = 'https://robertsspaceindustries.com/en/store/pledge/browse/game-packages';
                    registerBtn.target = '_blank'; // 在新标签页打开
                    registerBtn.className = 'register-btn';
                    registerBtn.textContent = '购买资格包';
                    registerBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        // 链接会在新标签页打开，不需要额外处理
                    });
                    modalActions.appendChild(registerBtn);

                    // --- 新增内容：添加警告文本 ---
                    const warningText1 = document.createElement('div');
                    warningText1.className = 'warning-text';
                    warningText1.textContent = '一般选最便宜的45USD的包购买，运气好能碰到游戏节日打折40.50USD或者带有（LTI）永久保险标志（有这个优先选这个）的资格包';
                    const warningText2 = document.createElement('div');
                    warningText2.className = 'warning-text';
                    warningText2.textContent = '资格包包含游戏资格和一艘最基础的飞船，可在官网机库里查看';
                    modalActions.appendChild(warningText1);
                    modalActions.appendChild(warningText2);
                    // --- 新增内容结束 ---


                } else if (taskId === 'task2.1') {
                    // 子级任务显示与父级相同的布局，但链接不同
                    modalContentArea.innerHTML = '<p>获取启动器：</p>';
                    const registerBtn = document.createElement('a');
                    registerBtn.href = 'https://install.robertsspaceindustries.com/rel/2/RSI%20Launcher-Setup-2.3.1.exe?_gl=1*1tno1qc*_gcl_au*MTk4NTI0MDU1OC4xNzQxNTM0MzM5LjUzNTY2OTk0MC4xNzQ0NDYwNDE4LjE3NDQ0NjA0MTc.*_ga*MzQ1NDIwMDY2LjE3NDE1MzQzMzk.*_ga_V6MWYXRQNP*MTc0NDcxNjU5MS4yNy4xLjE3NDQ3MjE2MTguNDMuMC4w';
                    registerBtn.target = '_blank'; // 在新标签页打开
                    registerBtn.className = 'register-btn';
                    registerBtn.textContent = '下载启动器';
                    registerBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        // 链接会在新标签页打开，不需要额外处理
                    });
                    modalActions.appendChild(registerBtn);

                } else if (taskId === 'task2.2') {
                    // 子级任务显示与父级相同的布局，但链接不同
                    modalContentArea.innerHTML = '<p>汉化补丁：</p>';
                    const registerBtn = document.createElement('a');
                    registerBtn.href = 'https://citizenwiki.cn/Localization';
                    registerBtn.target = '_blank'; // 在新标签页打开
                    registerBtn.className = 'register-btn';
                    registerBtn.textContent = '汉化组官网';
                    registerBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        // 链接会在新标签页打开，不需要额外处理
                    });
                    modalActions.appendChild(registerBtn);

                    // --- 新增内容：添加警告文本 ---
                    const warningText1 = document.createElement('div');
                    warningText1.className = 'warning-text';
                    warningText1.textContent = '新手推荐选择汉化组官网的<sc汉化盒子>来完成启动器和游戏本体的汉化（网站抽风就直接在系统的微软商店里下载）';
                    modalActions.appendChild(warningText1);
                    // --- 新增内容结束 ---

                } else if (taskId === 'task3') {
                    // 社区任务
                    modalContentArea.innerHTML = '<p>了解社区：</p>';
                    
                    const infoText1 = document.createElement('div');
                    infoText1.className = 'info-text';
                    infoText1.textContent = '社区主要涉及三大板块➊：玩家间自发组织的游戏交易的二级市场';
                    const infoText2 = document.createElement('div');
                    infoText2.className = 'info-text';
                    infoText2.textContent = '➋玩家间通过长时间游戏实践总结的约定俗成的一些规则';
                    const infoText3 = document.createElement('div');
                    infoText3.className = 'info-text';
                    infoText3.textContent = '➌玩家间自发组织的舰队/聊天群/频道/比赛等交流';
                    
                    modalContentArea.appendChild(infoText1);
                    modalContentArea.appendChild(infoText2);
                    modalContentArea.appendChild(infoText3);


                } else if (taskId === 'task4') {
                    // 官网任务
                    modalContentArea.innerHTML = '<p>探索官方网站，获取最新资讯：</p>';
                    
                    const infoText1 = document.createElement('div');
                    infoText1.className = 'info-text';
                    infoText1.textContent = '官网 (RSI): https://robertsspaceindustries.com/';
                    const infoText2 = document.createElement('div');
                    infoText2.className = 'info-text';
                    infoText2.textContent = '机库 (Hangar): 查看你拥有的飞船和物品。';
                    const infoText3 = document.createElement('div');
                    infoText3.className = 'info-text';
                    infoText3.textContent = '光谱 (Spectrum): 官方论坛，可以参与开发讨论和玩家交流。';
                    const infoText4 = document.createElement('div');
                    infoText4.className = 'info-text';
                    infoText4.textContent = '路线图 (Roadmap): 了解游戏未来的开发方向。';
                    
                    modalContentArea.appendChild(infoText1);
                    modalContentArea.appendChild(infoText2);
                    modalContentArea.appendChild(infoText3);
                    modalContentArea.appendChild(infoText4);


                } else if (taskId === 'task5') {
                    // 星际公民任务
                    modalContentArea.innerHTML = '<p>深入了解游戏本身：</p>';
                    
                    const infoText1 = document.createElement('div');
                    infoText1.className = 'info-text';
                    infoText1.textContent = '观看游戏宣传片和开发者直播 (Round the Verse)。';
                    const infoText2 = document.createElement('div');
                    infoText2.className = 'info-text';
                    infoText2.textContent = '阅读游戏手册 (Starmap, Jump Point 杂志)。';
                    const infoText3 = document.createElement('div');
                    infoText3.className = 'info-text';
                    infoText3.textContent = '了解游戏核心玩法：飞船战斗、贸易、探索、挖矿等。';
                    const infoText4 = document.createElement('div');
                    infoText4.className = 'info-text';
                    infoText4.textContent = '熟悉游戏内货币 (UEC, REC) 和经济系统。';
                    
                    modalContentArea.appendChild(infoText1);
                    modalContentArea.appendChild(infoText2);
                    modalContentArea.appendChild(infoText3);
                    modalContentArea.appendChild(infoText4);

                    const warningText = document.createElement('div');
                    warningText.className = 'warning-text';
                    warningText.textContent = '游戏内容庞大，需要时间学习。';
                    modalActions.appendChild(warningText);

                } else if (taskId === 'task6') {
                    // 42中队任务
                    modalContentArea.innerHTML = '<p>42中队：</p>';
                    
                    const infoText1 = document.createElement('div');
                    infoText1.className = 'info-text';
                    infoText1.textContent = '42中队是CIG真正的开发目标，星际公民是为42中队筹集资金的项目';
                    const infoText2 = document.createElement('div');
                    infoText2.className = 'info-text';
                    infoText2.textContent = '42中队已经基本完成，进入打磨优化阶段，预计26年发售';
                    const infoText3 = document.createElement('div');
                    infoText3.className = 'info-text';
                    // 创建一个 <a> 元素作为超链接
                    const link = document.createElement('a');
                    link.href = 'https://www.bilibili.com/video/BV1dSyeYkE4w/?spm_id_from=333.337.search-card.all.click&vd_source=e78ad6402f3fd4fa97ff6c816561c6b2';
                    link.textContent = '42中队实机演示（点击查看）';
                    link.target = '_blank'; // 在新标签页打开链接
                    // 将链接添加到 infoText3 这个 div 中
                    infoText3.appendChild(link);
                    
                    modalContentArea.appendChild(infoText1);
                    modalContentArea.appendChild(infoText2);
                    modalContentArea.appendChild(infoText3);

                } else {
                    // 默认内容
                    modalContentArea.innerHTML = '<p>请根据任务要求完成相关操作。</p>';
                }

                // 显示弹窗
                modalOverlay.classList.add('show');
            });
        });

        // 点击弹窗外部（背景）关闭弹窗
        modalOverlay.addEventListener('click', (e) => {
             if (e.target === modalOverlay) { // 确保点击的是背景而不是内容
                 closeModal();
             }
        });

        // 关闭弹窗的函数
        function closeModal() {
             modalOverlay.classList.remove('show'); // 隐藏弹窗

             // 处理任务框状态 (所有任务都有变色周期)
             if (currentTaskBox) {
                 const taskId = currentTaskBox.id;
                 // 增加该任务的周期计数
                 cycleCount[taskId] = (cycleCount[taskId] || 0) + 1;

                 if (cycleCount[taskId] === 1) {
                     // 第一个周期：添加完成状态（绿色）
                     currentTaskBox.classList.add('completed');
                 } else if (cycleCount[taskId] === 2) {
                     // 第二个周期：移除完成状态，恢复初始状态
                     currentTaskBox.classList.remove('completed');
                     // 重置计数器
                     cycleCount[taskId] = 0;
                 }
                 // 如果计数器 > 2 (理论上不会发生，因为会在2时重置)，也保持初始状态

                 // 更新所有连接线的颜色状态
                 updateConnectionColors();
             }
             
             currentTaskBox = null; // 清空当前引用
        }

        // 页面加载完成后绘制所有连接线和创建星空
        window.addEventListener('load', () => {
            console.log("Window loaded. Creating stars and drawing lines.");
            createStars();
            drawAllLines();
            initImageViewer();
        });

        // 如果窗口大小改变，重新绘制连接线
        window.addEventListener('resize', () => {
             console.log("Window resized. Redrawing lines.");
             drawAllLines();
        });

        // --- 缩放和平移功能实现 ---

        // 获取相关元素
        const zoomPanContainer = document.getElementById('zoom-pan-container');

        // 初始化变换状态
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let startX, startY, startTranslateX, startTranslateY;

        // 应用变换
        function applyTransform() {
            zoomPanContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
        }

        // 鼠标滚轮事件处理 (缩放) - 修复版
        zoomPanContainer.addEventListener('wheel', (e) => {
            e.preventDefault(); // 阻止默认的滚动行为

            // 获取鼠标在视口中的坐标
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // 确定缩放方向和强度
            const delta = e.deltaY;
            const zoomIntensity = 0.1;

            // 限制缩放范围
            const minScale = 0.1;
            const maxScale = 10;

            // 1. 计算当前变换的逆矩阵
            const currentMatrix = new DOMMatrix().translate(translateX, translateY).scale(scale);
            const inverseMatrix = currentMatrix.inverse();

            // 2. 将鼠标视口坐标转换为世界坐标 (未变换坐标系)
            const worldPoint = new DOMPoint(mouseX, mouseY).matrixTransform(inverseMatrix);

            // 3. 计算新的缩放比例
            // 使用指数缩放可以获得更平滑的感觉
            const scaleFactor = Math.pow(1.1, -delta * zoomIntensity);
            let newScale = scale * scaleFactor;

            // 4. 限制缩放范围
            newScale = Math.max(minScale, Math.min(maxScale, newScale));

            // 5. 计算应用新缩放后，世界坐标点在视口中的新位置
            const newMatrix = new DOMMatrix().translate(translateX, translateY).scale(newScale);
            const newScreenPoint = worldPoint.matrixTransform(newMatrix);

            // 6. 调整平移量，使世界坐标点固定在鼠标位置
            translateX += mouseX - newScreenPoint.x;
            translateY += mouseY - newScreenPoint.y;

            // 7. 更新缩放比例
            scale = newScale;

            // 8. 应用变换
            applyTransform();

            // 9. 重新绘制连接线
            drawAllLines();
        });

        // 鼠标按下事件处理 (开始拖拽)
        zoomPanContainer.addEventListener('mousedown', (e) => {
            // 确保是鼠标左键并且不是点击在任务框上
            if (e.button !== 0) return;

            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            startTranslateX = translateX;
            startTranslateY = translateY;

            // 添加鼠标移动和松开事件监听器
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
             // 防止文本选择
            e.preventDefault();
        });

        // 鼠标移动事件处理 (执行拖拽)
        function handleMouseMove(e) {
            if (!isDragging) return;

            // 计算鼠标移动的距离
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            // 更新平移量
            translateX = startTranslateX + dx;
            translateY = startTranslateY + dy;

            // 应用变换
            applyTransform();

            // 重新绘制连接线
            drawAllLines();
        }

        // 鼠标松开事件处理 (结束拖拽)
        function handleMouseUp(e) {
            // 确保是鼠标左键
            if (e.button !== 0) return;

            isDragging = false;

            // 移除事件监听器
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }


         // 轮播图控制函数（无自动播放）
function initCarousel() {
    const carousel = document.getElementById('register-carousel');
    if (!carousel) return;
    
    const slides = carousel.querySelectorAll('.carousel-slide');
    const dots = carousel.querySelectorAll('.carousel-dot');
    const prevBtn = carousel.querySelector('.carousel-prev');
    const nextBtn = carousel.querySelector('.carousel-next');
    
    let currentSlide = 0;
    
    // 切换到指定幻灯片
    function goToSlide(index) {
        // 边界检查
        if (index < 0) index = slides.length - 1;
        if (index >= slides.length) index = 0;
        
        // 更新幻灯片
        slides.forEach(slide => slide.classList.remove('active'));
        dots.forEach(dot => dot.classList.remove('active'));
        
        slides[index].classList.add('active');
        dots[index].classList.add('active');
        
        currentSlide = index;
    }
    
    // 下一张幻灯片
    function nextSlide() {
        goToSlide(currentSlide + 1);
    }
    
    // 上一张幻灯片
    function prevSlide() {
        goToSlide(currentSlide - 1);
    }
    
    // 打开全屏查看器
    function openViewer() {
        const viewer = document.getElementById('image-viewer');
        const viewerImage = document.getElementById('viewer-image');
        const viewerDots = document.getElementById('viewer-dots');
        
        // 设置当前图片
        viewerImage.style.backgroundImage = slides[currentSlide].style.backgroundImage;
        
        // 创建指示器
        viewerDots.innerHTML = '';
        slides.forEach((slide, index) => {
            const dot = document.createElement('span');
            dot.className = `viewer-dot ${index === currentSlide ? 'active' : ''}`;
            dot.setAttribute('data-index', index);
            dot.addEventListener('click', () => {
                goToSlide(index);
                viewerImage.style.backgroundImage = slides[index].style.backgroundImage;
                updateViewerDots(index);
            });
            viewerDots.appendChild(dot);
        });
        
        viewer.classList.add('show');
    }
    
    // 更新查看器指示器
    function updateViewerDots(index) {
        const dots = document.querySelectorAll('.viewer-dot');
        dots.forEach(dot => dot.classList.remove('active'));
        dots[index].classList.add('active');
    }
    
    // 事件监听
    prevBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        prevSlide();
    });
    
    nextBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        nextSlide();
    });
    
    // 点选指示器
    dots.forEach(dot => {
        dot.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(dot.getAttribute('data-index'));
            goToSlide(index);
        });
    });
    
    // 点击图片打开全屏查看器
    slides.forEach(slide => {
        slide.addEventListener('click', (e) => {
            e.stopPropagation();
            openViewer();
        });
    });
    
    // 点击轮播容器也打开全屏查看器
    carousel.addEventListener('click', (e) => {
        if (e.target === carousel) {
            openViewer();
        }
    });
}

// 全屏查看器控制
function initImageViewer() {
    const viewer = document.getElementById('image-viewer');
    const closeBtn = viewer.querySelector('.viewer-close');
    const prevBtn = viewer.querySelector('.viewer-prev');
    const nextBtn = viewer.querySelector('.viewer-next');
    const viewerImage = document.getElementById('viewer-image');
    
    let currentViewerIndex = 0; // 添加当前查看器索引
    
    // 关闭查看器
    function closeViewer() {
        viewer.classList.remove('show');
    }
    
    // 切换到下一张图片
    function nextViewerImage() {
        const carousel = document.getElementById('register-carousel');
        if (!carousel) return;
        
        const slides = carousel.querySelectorAll('.carousel-slide');
        
        // 计算下一张索引（循环）
        currentViewerIndex = (currentViewerIndex + 1) % slides.length;
        viewerImage.style.backgroundImage = slides[currentViewerIndex].style.backgroundImage;
        updateViewerDots(currentViewerIndex);
        
        // 同时更新轮播图状态
        goToCarouselSlide(currentViewerIndex);
    }
    
    // 切换到上一张图片
    function prevViewerImage() {
        const carousel = document.getElementById('register-carousel');
        if (!carousel) return;
        
        const slides = carousel.querySelectorAll('.carousel-slide');
        
        // 计算上一张索引（循环）
        currentViewerIndex = (currentViewerIndex - 1 + slides.length) % slides.length;
        viewerImage.style.backgroundImage = slides[currentViewerIndex].style.backgroundImage;
        updateViewerDots(currentViewerIndex);
        
        // 同时更新轮播图状态
        goToCarouselSlide(currentViewerIndex);
    }
    
    // 更新查看器指示器
    function updateViewerDots(index) {
        const dots = document.querySelectorAll('.viewer-dot');
        dots.forEach(dot => dot.classList.remove('active'));
        dots[index].classList.add('active');
        currentViewerIndex = index; // 更新当前索引
    }
    
    // 更新轮播图状态
    function goToCarouselSlide(index) {
        const carousel = document.getElementById('register-carousel');
        if (!carousel) return;
        
        const slides = carousel.querySelectorAll('.carousel-slide');
        const dots = carousel.querySelectorAll('.carousel-dot');
        
        slides.forEach(slide => slide.classList.remove('active'));
        dots.forEach(dot => dot.classList.remove('active'));
        
        slides[index].classList.add('active');
        dots[index].classList.add('active');
    }
    
    // 事件监听
    closeBtn.addEventListener('click', closeViewer);
    prevBtn.addEventListener('click', prevViewerImage);
    nextBtn.addEventListener('click', nextViewerImage);
    
    // 点击背景关闭
    viewer.addEventListener('click', (e) => {
        if (e.target === viewer) {
            closeViewer();
        }
    });
    
    // ESC键关闭
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && viewer.classList.contains('show')) {
            closeViewer();
        }
    });
    
    // 点击指示器切换图片
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('viewer-dot')) {
            const index = parseInt(e.target.getAttribute('data-index'));
            currentViewerIndex = index;
            const carousel = document.getElementById('register-carousel');
            if (carousel) {
                const slides = carousel.querySelectorAll('.carousel-slide');
                viewerImage.style.backgroundImage = slides[index].style.backgroundImage;
                updateViewerDots(index);
                goToCarouselSlide(index);
            }
        }
    });
}

// 初始化全屏查看器
initImageViewer();

    </script>
</body>
</html>



